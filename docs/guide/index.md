<Logo :animation="false"></Logo>

---

Движок `Orillusion` является легковесным движком рендеринга, который полностью поддерживает [WebGPU](https://www.orillusion.com/webgpu.html) стандарт. На основе последних стандартах графических `Web` API, Мы сделали много экспериментов и попыток реализовать множество методов и функций, которые были ранее трудно или невозможно достичь в web. Мы суммировали архитектуру и характеристики движка из следующих аспектов.

## Поддержка WebGPU 
Основная конструкция движка полностью следует последнему стандарту `WebGPU` без учета совместимости с существующим стандартом [WebGL](https://www.khronos.org/webgl/). С непрерывным развитием `WebGPU API` и `WGSL` , Мы также будем быстро обновлять и выводить возможности вычислений и рендеринга лежащего в основе движка `WebGPU` , улучшая производительность движка.

## ECS Component-Based System
По мере развития структуры движка отрасль, как правило, начала принимать принцип проектирования разработки «композиции над наследованием». Поэтому мы отказались от архитектуры на основе наследования и выбрали последнюю [ECS](https://wikipedia.org/wiki/Entity_component_system) архитектуру на основе компонентов, как философию дизайна для основы движка. Устранение сложности цепочек наследования и переплетенной функциональности в модели наследования и перепроектирование посредством развязки, инкапсуляции и модуляризации, разработчики могут гибко объединять и расширять функциональность.

## Ориентированный на данные дизайн
Строгая архитектура `ECS` требует, чтобы `сущность`, `компонент` и `Система` были полностью независимо разделены. Эта проектная парадигма может привести к большему улучшению оптимизации данных и производительности. Тем не менее, это также вызывает значительные негативные проблемы, а именно высокие затраты на развитие и трудности. Следовательно, учитывая сложность использования разработчиков и привычки разработки веб-разработчиков, мы приняли основную концепцию `DO` в `ECS` и внедрили структуру `DO` по требованию. Текущее использование состоит в том, чтобы создать непрерывную память в `графическом процессоре` и реализацию эффективной передачи данных между `ЦП` и `ГПУ` по картированию памяти, сокращая время ожидания и частоты обмена данными между `CPU` и `GPU`. Этот подход может улучшить уровень попадания в кэш, улучшить производительность и обеспечить общую простоту разработки и использования движка.

<!-- ## WASM Acceleration
`JavaScript эффективность работы в [V8](https://v8.dev/) kernel уже очень высокая, Но между ним и нативной средой все еще есть какой -то разрыв. Много сложных математических расчетов логики в трехмерных сценах по -прежнему необходимо рассчитывать на `CPU`. Чтобы повысить эффективность, мы представили поддержку [WASM](https://webassembly.org/), который передает большое количество `CPU` вычислений требований для нативных вычислительных модулей, а не полагаться на поток `JS, который значительно улучшает использование процессора и вычислительных характеристик. -->

<!-- ## Cluster Forward Rendering
Обыкновенный передовой рендеринг - самый простой конвейер рендеринга, Но его вычислительная сложность `M x N` (M - количество объектов, а N - количество динамических источников света), что не подходит для сцен со сложными динамическими источниками света, и будет много `Overdraw`. Наш подход состоит в том, чтобы сначала реализовать пайплайн рендеринга `Tile Forward Rendering/Forward+ Rendering` , который делит пространство экрана на `Плитки` в двух измерениях. Благодаря предварительно рассмотрению информации о глубине и используя «вычислительный шейдер» для удаления источников света, которые не способствуют `Tile`, Мы уменьшаем вычислительное бремя. Кроме того, мы принимаем технику `Cluster Light Culling` техника, чтобы разделить направление глубины, дальнейшее уменьшение диапазона влияния освещения и достижения хороших результатов рендеринга для динамических сцен с несколькими источниками света. -->

## Clustered Light Culling (кластерный отбор света)
Это схема отбора света в `Clustered Forward Rendering`. Пространственное разделение выполняется в двух измерениях `(Tile)` и трёх измерения `(Cluster)`, и только источники света, которые способствуют блочному пространству, рассчитываются для удаления неэффективных источников света и повышения эффективности вычислительной техники. Из -за ограничений `WebGL`-ного `Uniform Buffer`, Количество поддерживаемых источников света относительно невелико, обычно в пределах 10. С введением «буфера хранения» в `webgpu`, он в основном напрямую нацелен на предел памяти графического процессора. Пока  self-memory management и оптимизация выполняются хорошо, сила «графического процессора» может быть полностью использована для достижения рендеринга множественного источника света.

## Система симуляции физики
Мы впервые реализовали `ammo.js` Как основное физическое моделирование со стороны процессора. В то же время мы строим движок моделирования на основе `GPU` на основе `вычислительного шейдера`, включая частицы, жидкости, мягкие тела, жесткие тела, одежду и т. Д. В эпоху `WebGL`, для соответствующего процесса расчета могли использоваться только структура данных вершин и текстур., который был сложным и неэффективным. С `Compute Shader` в `WebGPU`, память и структуры данных более гибки, давая нам много места для воображения. В настоящее время было реализовано много превосходных случаев симуляции физики, и более мощные функции моделирования физики быстро итерируют.

## Physics-Based Material Rendering
Мы внедрили самые основные `Blinn-phong` модели материала рендеринг. Чтобы добиться лучшего реализма, рендер эффектов, Мы полагаемся на `HDR Light` и также реализовали рендер материала на основе `PBR (Physically-based rendering)`. В настоящее время это стандартная функция в основных движках и является распространенным базовым требованием движка.

## Dynamic Diffuse Global Illumination (DDGI)
Алгоритм `DDGI (Dynamic Diffuse Global Illumination)` глобальный алгоритм освещения, основанный на `Probe`. Большое количество `Probe` нужно помещать в пространстве и сгруппировать вместе, чтобы сформировать `DDGI Volume`. `Compute Shader` используется для вычисления irradiance (информация об освещенности) и `G-buffer (информация о геометрии)` каждой `Probe`, которые хранятся путем отображения от сферы в октаэдр, а затем до квадрата. При затенении только к информации о свете и геометрии, хранящейся в окружающей среде `probe` необходимо получить доступ для расчета информации о затенении точки затенения. Привязывание `Volume` с камерой и перемещение с ней будет применять косвенное освещение к объектам в пределах `Volume`. В настоящее время мы установили максимум 32 источника непрямого света, основываясь на общей производительности рендеринга.

<!-- ## GPU Skeletal Animation
Основываясь на структуре `webgl`, анимацию скининга легко реализовать в вершином шейдере. Анимация скелета обычно рассчитывается в `JavaScript` а затем передается в `GPU` для рендеринга. С помощью `Compute Shader` в `WebGPU`, который имеет более гибкие структуры данных, мы можем перенести процесс расчета скелетной анимации в `GPU`, значительное повышая вычислительную эффективность и производительность. Конечно, мы также предоставляем клиентам решения скелетной анимации на основе `CPU`, какие пользователи могут выбрать по мере необходимости. -->

<!-- ## Frustum Culling
Цель Frustum Culling состоит в том, чтобы отображать только объекты внутри вида камеры Frustum. В настоящее время стадия обрезки `GPU's Rendering Tipeline автоматически выполняет отбор, Но ранее «ЦП» по -прежнему передавал информацию в `grpu` vertex shader `через` drawcall ', и эта информация за пределами Frustum также будет участвовать во многих процессах расчета. Наше решение на основе вида Frustum заключается в решении проблемы расчета этой дополнительной информации в источнике. Во -первых, мы создаем ограничивающую коробку «AABB» для модели, полагаясь на преимущества`DO`, complete the shared transmission of index data from `CPU` to `GPU`, and then use the `Compute Shader` to calculate whether the frustum and bounding box intersect. If they intersect, we submit the `DrawCall`, otherwise no rendering is performed. This greatly improves rendering efficiency and reduces additional computation costs. -->

## Богатые эффекты пост-процессинга
`Post-processing effects` являются важным способом улучшения атмосферы визуализированного контента. На основе `compute shader` в `WebGPU`, В настоящее время мы реализовали обычно используемые эффекты после обработки, такие как `HDR Bloom`, `Screen Space Reflections`, и `Ambient Occlusion`. Полагаясь на общие вычислительные возможности `WebGPU`, Мы можем более эффективно использовать вычислительные преимущества `GPU` и достичь очень хороших результатов.

Например, [Screen Space Reflections (SSR)](/guide/advanced/post_ssr) эффект отражения, реализованный на основе размера пространства экрана. По сравнению с плоскими отражениями, он может достичь отражения на любой поверхности на сцене без дополнительных `DrawCall`, и очень популярная техника размышлений в реальном времени. Во -первых, каждый пиксель объекта пространства экрана должен рассчитать его вектор отражения. Затем необходимо определить, является ли глубина пространства экрана `Ray Marching` координировать и глубину объекта, хранящегося в глубинном пересечении. Наконец, отрегулируйте шероховатость и используйте цвет точки пересечения в качестве цвета отражения, чтобы завершить затенение. Мы реализуем все вычисления в этом процессе, используя `Compute Shader` из `WebGPU`, избегая потребления `CPU`. В конце концов, мы можем представить очень хорошие эффекты отражения в браузере.

Для получения более расширенных эффектов постобработки, пожалуйста, обратитесь к [PostEffects](/guide/advanced/posteffect)